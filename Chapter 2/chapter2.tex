\section{Chapter 2}

\subsection{Primitive Built-in Types}

\subsubsection{Arithmetic Types}

\paragraph{Exercise 2.1} The different integer types vary in their minimum bit sizes and so their minimum value range:
\begin{itemize}
	\item 
		\texttt{short} -- 16 bits gives a value range of -32768 -- 32767.
	\item 
		\texttt{int} -- 16 bits gives a value range of -32768 -- 32767.
	\item 
		\texttt{long} -- 32 bits gives a value range of -2147483648 -- 2147483647.
	\item 
		\texttt{long long} -- 64 bits vies a value range of -9223372036854775808 -- 9223372036854775807.
\end{itemize}

\texttt{unsigned} types do not include negative values, that is, values $\geq 0$, for example if we consider \texttt{unsigned int} the value range is 0 -- 65536. Of course a \texttt{signed} type takes negative values.

Lastly, both \texttt{float} and \texttt{double} represent decimal precision values. The difference is in the accuracy of precision, a \texttt{float} is precise to 6 significant digits and \texttt{double} is precise to 10 significant digits.

\paragraph{Exercise 2.2}
They should all be \texttt{double} as they all involved decimal figures.

\subsubsection{Type Conversions}

\paragraph{Exercise 2.3}
Assuming the machine is 32 bits for integers the outputs are (in order):
\begin{itemize}
	\begin{multicols}{2}
		\item 32
		\item 4294967264
		\item 32
		\item -32
		\item 0
		\item 0
	\end{multicols}
\end{itemize}

\paragraph{Exercise 2.4}
See ex24.cpp.

\subsubsection{Literals}

\paragraph{Exercise 2.5}
\begin{itemize}
	\item [(a)]
		In order: character literal; wide character literal; string literal; wide character string literal.
	\item [(b)]
		In order: integer; unsigned integer; long integer; unsigned long integer; octal integer; hexadecimal integer.
	\item [(c)]
		In order: double; float; long double.
	\item [(d)]
		In order: integer; unsigned integer; double; double.
\end{itemize}

\paragraph{Exercise 2.6}
In the first statement the definitions use integer literals so the values are what we expect, that is, \texttt{month = 9} and \texttt{day = 7}. In the second statement we try to define integers using octals however there is an error as 09 is not an octal and will throw an error.

\paragraph{Exercise 2.7}
\begin{itemize}
	\item [(a)]
		This is a string literal which represents ``Who goes with Fergus?''
	\item [(b)]
		The value is 3.1 and is a long double.
	\item [(c)]
		The value is 1024 and is a float.
	\item [(d)]
		The value is 3.14 and is a long double.
\end{itemize}

\paragraph{Exercise 2.8}
See ex28.cpp.

\subsection{Variables}

\subsubsection{Variable Definitions}

\paragraph{Exercise 2.9}
\begin{itemize}
	\item [(a)]
		Cannot use variable before it has been declared. To correct:\\
		\texttt{int input\_value;}\\
		\texttt{std::cin >> input\_value;}
	\item [(b)]
		Cannot use double in list initialisation since narrowing value may lose data. To correct:\\
		\texttt{double i = $\{$ 3.14 $\}$;}
	\item [(c)]
		Cannot use variable to initialise another variable before it has been initialised. To correct:\\
		\texttt{double wage = 9999.99;}\\
		\texttt{double salary = wage;}
	\item [(d)]
		This will initialise \texttt{i} to be an \texttt{int} but it will truncate it's value from 3.14 to 3.
\end{itemize}

\paragraph{Exercise 2.10}
\begin{itemize}
	\item \texttt{global\_str} will be an empty string.
	\item \texttt{global\_int} will be 0.
	\item \texttt{local\_int} will be undefined.
	\item \texttt{local\_str} will be an empty string.
\end{itemize}

\subsubsection{Variable Declarations and Definitions}

\paragraph{Exercise 2.11}
\begin{itemize}
	\item [(a)]
		This is a definition since the variable is initialised and so memory is allocated for the variable.
	\item [(b)]
		This is a definition as the variable is defined locally and so memory is allocated for it.
	\item [(c)]
		This is a declaration of a variable as it specifies the variable is external without initialising its value.
\end{itemize}

\subsubsection{Identifiers}

\paragraph{Exercise 2.12}
\texttt{double} is a reserved C++ keyword and so is invalid, \texttt{catch-22} does not include valid characters in an identifier and so is invalid and lastly, \texttt{1\_or\_2} is invalid as it begins with a number.

\subsubsection{Scope of a Name}

\paragraph{Exercise 2.13}
Since \texttt{i} is defined globally and locally, within the block scope its value is that derived from initialisation within the block. So \texttt{j} will have value 100.

\paragraph{Exercise 2.14}
The program is legal since variables can be redefined in an inner scope (here this is the \texttt{for} loop). The program prints \texttt{100 45} since the value of \texttt{sum} is the sum of the numbers 0--9.

\subsection{Compound Types}

\subsubsection{References}

\paragraph{Exercise 2.15}
The definition in (b) and (d) are invalid as reference types must be initialised to an object.

\paragraph{Exercise 2.16}
\begin{itemize}
	\item [(a)]
		Valid. Assigns the value 3.314159 to \texttt{d}.
	\item [(b)]
		Valid. Assigns 0.0 to \texttt{d}.
	\item [(c)]
		Valid. Assigns 0 to \texttt{i}.
	\item [(d)]
		Valid. Assigns 0 to \texttt{i}.
\end{itemize}

\paragraph{Exercise 2.17}
This prints \texttt{10 10}.

\subsubsection{Pointers}

\paragraph{Exercise 2.18}
See ex218.cpp.

\paragraph{Exercise 2.19}
Pointers and references both ``refer'' to another object. However, references are not objects, that is they are not allocated space in memory and as such they cannot be rebound to another object after initialisation. This also means they \textit{must} be initialised in their definition. A pointer is an object and can refer to several objects over its lifetime since it has memory allocated to it, the address which it stores can be redefined later on.

\paragraph{Exercise 2.20}
\begin{itemize}
	\item Initialise \texttt{i} to 42.
	\item Initialise the pointer \texttt{p1} to point to \texttt{i}.
	\item Assign to \texttt{i} the value \texttt{i * i}
\end{itemize}

\paragraph{Exercise 2.21}
\begin{itemize}
	\item [(a)]
		This is invalid since \texttt{dp} is a \texttt{double} pointer and so cannot point to an \texttt{int}.
	\item [(b)]
		Initialises an \texttt{int} pointer to 0, that is, the pointer is a null pointer.
	\item [(c)]
		Initialises an \texttt{int} pointer that points to the \texttt{int} object \texttt{i}.
\end{itemize}

\paragraph{Exercise 2.22}
The first \texttt{if} checks if \texttt{p} is a null pointer or not. If it is not a null pointer it will execute its corresponding block. The second \texttt{if} checks if \texttt{p} points to an \texttt{int} object of value 0 or not. If it points to an object with value non-zero the corresponding block will execute.

\paragraph{Exercise 2.23}
No. If a pointer is uninitialised then it displays undefined behaviour. We do not know if the memory address it stores points to something valid or not.

\paragraph{Exercise 2.24}
We have that \texttt{void*} pointers can point to objects of any type, since their purpose is to point to objects which we do now know their type a priori. However, a pointer of a specified type, for example \texttt{long}, can \textit{only} point to objects of the same type. Hence, initialising a \texttt{long} pointer to an \texttt{int} object will raise an error.

\subsubsection{Understanding Compound Type Declarations}

\paragraph{Exercise 2.25}
\begin{itemize}
	\item [(a)]
		\texttt{ip} is an \texttt{int} pointer with no value; \texttt{i} is an \texttt{int} with no value; \texttt{r} is an \texttt{int} reference with no value.
	\item [(b)]
		\texttt{i} is an \texttt{int} with no value; \texttt{ip} is an \texttt{int} null pointer.
	\item [(c)]
		\texttt{ip} is an \texttt{int} pointer with no value; \texttt{ip2} is an \texttt{int} with no value.
\end{itemize}

\subsubsection{\texttt{const} Qualifier}

\paragraph{Exercise 2.26}
Assuming the definitions are in order of presentation then (b) and (c) are legal and (a) and (d) are illegal. In (a) the issue is that we are defining a \texttt{const} without initialising and in (d) we are trying to iterate a \texttt{const}.

\subsubsection{References to \texttt{const}}

\subsubsection{Pointers to \texttt{const}}

\paragraph{Exercise 2.27}
\begin{itemize}
	\item [(a)]
		This is not legal since references cannot be bound to literals and only to objects.
	\item [(b)]
		This is legal as \texttt{p2} is a low-level \texttt{const} so as long as \texttt{i2} is an \texttt{int} this is fine.
	\item [(c)]
		This is legal as we are able to assign a literal to a reference to \texttt{const}.
	\item [(d)]
		This is legal as pointer to \texttt{const} \textit{think} they point to a \texttt{const}. In the event that \texttt{i2} is not a \texttt{const} all this means is that we cannot assign to \texttt{i2} through \texttt{p3}.
	\item [(e)]
		This is legal however \texttt{i2} cannot be assigned to through \texttt{p1}.
	\item [(f)]
		This is illegal as \texttt{r2} is not initialised. The low-level \texttt{const} here is redundant as references by their nature cannot be rebound after initialisation.
	\item [(g)]
		This is legal, however \texttt{i} must be assigned to directly if not already.
\end{itemize}

\paragraph{Exercise 2.28}
There are errors in (a)--(e). In each of them there is either a \texttt{const} pointer or \texttt{const} variable which is not initialised in its definition. Part (f) is fine and defines a pointer to \texttt{const int}.

\paragraph{Exercise 2.29}
\begin{itemize}
	\item [(a)]
		Legal as assignment just copies the value, so you can assign a \texttt{const} variable to a non\texttt{const} variable.
	\item [(b)]
		Illegal as \texttt{p3} is a low-level \texttt{const} and \texttt{p1} is not.
	\item [(c)]
		Illegal as you cannot use a non\texttt{const} pointer to point to a \texttt{const} variable.
	\item [(d)]
		Legal as \texttt{ic} is a \texttt{const} and \texttt{p3} is a pointer to \texttt{const}.
	\item [(e)]
		Illegal for the same reason as in part (b).
	\item [(f)]
		Legal as the copying a value does not take into consideration whether the objects are both \texttt{const} or not.
\end{itemize}

\subsubsection{Top-Level \texttt{const}}

\paragraph{Exercise 2.30}
In order of presentation in the text:
\begin{itemize}
	\item low-level
	\item neither
	\item \texttt{p1} is neither; \texttt{r1} is top-level
	\item \texttt{p2} is low-level; \texttt{p3} is both; and \texttt{r2} is both.
\end{itemize}

\paragraph{Exercise 2.31}
In order of presentation in the text:
\begin{itemize}
	\item 
		This is legal as \texttt{r1} is only top-level so the referenced object is not a \texttt{const} and hence can be assigned to.
	\item 
		This is illegal as \texttt{p2} is low-level and so can only be assigned to other low-level objects. Otherwise we could assign to a (potentially) \texttt{const} object and create an error.
	\item 
		This is legal. Even though \texttt{p2} is low-level and \texttt{p1} is neither, when copying in assignment, the compiler will convert \texttt{p1} temporarily to low-level before continuing with assignment.
	\item 
		This is illegal as in the second case.
	\item 
		This is legal as both pointers are low-level.
\end{itemize}

\subsubsection{\texttt{constexpr} and Constant Expressions}

\paragraph{Exercise 2.32}
The code is illegal as the pointer \texttt{p} is initialised with type \texttt{int} instead of \texttt{int*}. Depending on whether the code is intended to initialise \texttt{p} as a \texttt{nullptr} or to point at \texttt{null} the following codes will gives the desired result, respectively,
\begin{center}
	\texttt{int null = 0, *p = 0;}
\end{center}
or,
\begin{center}
	\texttt{int null = 0, *p = \&null;}
\end{center}

\paragraph{Exercise 2.33}
\begin{itemize}
	\item 
		\texttt{a}, \texttt{b} and \texttt{c} are of type \texttt{int} and so will be set to the value of 42.
	\item 
		\texttt{d} is of type \texttt{int} pointer and so cannot be assigned a literal.
	\item 
		\texttt{e} is of type \texttt{const int} pointer and so cannot be assigned a literal.
	\item 
		\texttt{g} is of type \texttt{reference} and cannot be assigned after initialisation.
\end{itemize}

\paragraph{Exercise 2.34}
See ex234.cpp

\paragraph{Exercise 2.35}
The code given is:
\begin{flushleft}
		\texttt{const int i = 42;}\\
		\texttt{auto j = i; const auto \&k = i; auto *p = \&i;}\\
		\texttt{const auto j2 = i, \&k2 = i;}
\end{flushleft}
In order we have; \texttt{i} is of type \texttt{const int}; \texttt{j} is of type \texttt{int}; \texttt{k} is of type \texttt{const int}; \texttt{p} is of type pointer to \texttt{const int}; \texttt{j2} is of type \texttt{const int}; and \texttt{k2} is of type reference to \texttt{const int}. See the file ex235.cpp for the code portion of this exercise.
