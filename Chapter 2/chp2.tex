\documentclass[12pt, a4paper]{article}
\usepackage{algorithms}

\begin{document}
This document contains all the non-coding exercises of Chapter 2 of C++ Primer.
\subsubsection*{Exercise 2.1}

The different integer types vary in their minimum bit sizes and so their minimum value range:
\begin{itemize}
	\item [\texttt{short}]
		16 bits gives a value range of -32768 -- 32767.
	\item [\texttt{int}]
		16 bits gives a value range of -32768 -- 32767.
	\item [\texttt{long}]
		32 bits gives a value range of -2147483648 -- 2147483647.
	\item [\texttt{long long}]
		64 bits vies a value range of -9223372036854775808 -- 9223372036854775807.
\end{itemize}

\texttt{unsigned} types do not include negative values, that is, values $\geq 0$, for example if we consider \texttt{unsigned int} the value range is 0 -- 65536. Of course a \texttt{signed} type takes negative values.

Lastly, both \texttt{float} and \texttt{double} represent decimal precision values. The difference is in the accuracy of precision, a \texttt{float} is precise to 6 significant digits and \texttt{double} is precise to 10 significant digits.

\subsubsection*{Exercise 2.2}
They should all be \texttt{double} as they all involved decimal figures.

\subsubsection*{Exercise 2.3}
Assuming the machine is 32 bits for integers the outputs are (in order):
\begin{itemize}
	\item 32
	\item 4294967264
	\item 32
	\item -32
	\item 0
	\item 0
\end{itemize}

\subsubsection*{Exercise 2.4}
See ex24.cpp.

\subsubsection*{Exercise 2.5}
\begin{itemize}
	\item [(a)]
		In order: character literal; wide character literal; string literal; wide character string literal.
	\item [(b)]
		In order: integer; unsigned integer; long integer; unsigned long integer; octal integer; hexadecimal integer.
	\item [(c)]
		In order: double; float; long double.
	\item [(d)]
		In order: integer; unsigned integer; double; double.
\end{itemize}

\subsubsection*{Exercise 2.6}
In the first statement the definitions use integer literals so the values are what we expect, that is, \texttt{month = 9} and \texttt{day = 7}. In the second statement we try to define integers using octals however there is an error as 09 is not an octal and will throw an error.

\subsubsection*{Exercise 2.7}
\begin{itemize}
	\item [(a)]
		This is a string literal which represents ``Who goes with Fergus?''
	\item [(b)]
		The value is 3.1 and is a long double.
	\item [(c)]
		The value is 1024 and is a float.
	\item [(d)]
		The value is 3.14 and is a long double.
\end{itemize}

\subsubsection*{Exercise 2.8}
See ex28.cpp.

\subsubsection*{Exercise 2.9}
\begin{itemize}
	\item [(a)]
		Cannot use variable before it has been declared. To correct:\\
		\texttt{int input\_value;}\\
		\texttt{std::cin >> input\_value;}
	\item [(b)]
		Cannot use double in list initialisation since narrowing value may lose data. To correct:\\
		\texttt{double i = $\{$ 3.14 $\}$;}
	\item [(c)]
		Cannot use variable to initialise another variable before it has been initialised. To correct:\\
		\texttt{double wage = 9999.99;}\\
		\texttt{double salary = wage;}
	\item [(d)]
		This will initialise \texttt{i} to be an \texttt{int} but it will truncate it's value from 3.14 to 3.
\end{itemize}

\subsubsection*{Exercise 2.10}
\begin{itemize}
	\item \texttt{global\_str} will be an empty string.
	\item \texttt{global\_int} will be 0.
	\item \texttt{local\_int} will be undefined.
	\item \texttt{local\_str} will be an empty string.
\end{itemize}

\subsubsection*{Exercise 2.11}
\begin{itemize}
	\item [(a)]
		This is a definition since the variable is initialised and so memory is allocated for the variable.
	\item [(b)]
		This is a definition as the variable is defined locally and so memory is allocated for it.
	\item [(c)]
		This is a declaration of a variable as it specifies the variable is external without initialising its value.
\end{itemize}

\subsubsection*{Exercise 2.12}
\texttt{double} is a reserved C++ keyword and so is invalid, \texttt{catch-22} does not include valid characters in an identifier and so is invalid and lastly, \texttt{1\_or\_2} is invalid as it begins with a number.

\subsubsection*{Exercise 2.13}
Since \texttt{i} is defined globally and locally, within the block scope its value is that derived from initialisation within the block. So \texttt{j} will have value 100.

\subsubsection*{Exercise 2.14}
The program is legal since variables can be redefined in an inner scope (here this is the \texttt{for} loop). The program prints \texttt{100 45} since the value of \texttt{sum} is the sum of the numbers 0--9.

\subsubsection*{Exercise 2.15}
The definition in (b) and (d) are invalid as reference types must be initialised to an object.

\subsubsection*{Exercise 2.16}
\begin{itemize}
	\item [(a)]
		Valid. Assigns the value 3.314159 to \texttt{d}.
	\item [(b)]
		Valid. Assigns 0.0 to \texttt{d}.
	\item [(c)]
		Valid. Assigns 0 to \texttt{i}.
	\item [(d)]
		Valid. Assigns 0 to \texttt{i}.
\end{itemize}

\subsubsection*{Exercise 2.17}
This prints \texttt{10 10}.

\subsubsection*{Exercise 2.18}
See ex218.cpp.

\subsubsection*{Exercise 2.19}
Pointers and references both ``refer'' to another object. However, references are not objects, that is they are not allocated space in memory and as such they cannot be rebound to another object after initialisation. This also means they \textit{must} be initialised in their definition. A pointer is an object and can refer to several objects over its lifetime since it has memory allocated to it, the address which it stores can be redefined later on.

\subsubsection*{Exercise 2.20}
\begin{itemize}
	\item Initialise \texttt{i} to 42.
	\item Initialise the pointer \texttt{p1} to point to \texttt{i}.
	\item Assign to \texttt{i} the value \texttt{i * i}
\end{itemize}

\subsubsection*{Exercise 2.21}
\begin{itemize}
	\item [(a)]
		This is invalid since \texttt{dp} is a \texttt{double} pointer and so cannot point to an \texttt{int}.
	\item [(b)]
		Initialises an \texttt{int} pointer to 0, that is, the pointer is a null pointer.
	\item [(c)]
		Initialises an \texttt{int} pointer that points to the \texttt{int} object \texttt{i}.
\end{itemize}

\subsubsection*{Exercise 2.22}
The first \texttt{if} checks if \texttt{p} is a null pointer or not. If it is not a null pointer it will execute its corresponding block. The second \texttt{if} checks if \texttt{p} points to an \texttt{int} object of value 0 or not. If it points to an object with value non-zero the corresponding block will execute.

\subsubsection*{Exercise 2.23}
No. If a pointer is uninitialised then it displays undefined behaviour. We do not know if the memory address it stores points to something valid or not.

\subsubsection*{Exercise 2.24}
We have that \texttt{void*} pointers can point to objects of any type, since their purpose is to point to objects which we do now know their type a priori. However, a pointer of a specified type, for example \texttt{long}, can \textit{only} point to objects of the same type. Hence, initialising a \texttt{long} pointer to an \texttt{int} object will raise an error.

\subsubsection*{Exercise 2.25}
\begin{itemize}
	\item [(a)]
		\texttt{ip} is an \texttt{int} pointer with no value; \texttt{i} is an \texttt{int} with no value; \texttt{r} is an \texttt{int} reference with no value.
	\item [(b)]
		\texttt{i} is an \texttt{int} with no value; \texttt{ip} is an \texttt{int} null pointer.
	\item [(c)]
		\texttt{ip} is an \texttt{int} pointer with no value; \texttt{ip2} is an \texttt{int} with no value.
\end{itemize}
\end{document}
